<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: utils.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>define(function () {
    "use strict";

    /**
     * Useful methods for HTML Elements.
     * @name Utils
     * @namespace
     */
    var Utils = function () {
        this.initialize();
    };

    Utils.prototype = /** @lends Utils */{

        /**
         * Sets up some initial things.
         */
        initialize: function () {
            this._setupBindPolyfill();
        },

        /**
         * Adds a CSS class to an element.
         * @param {HTMLElement} el - The element to add a class to.
         * @param {string} className - The css class value to add
         */
        addClass: function  (el, className) {
            if (!this.hasClass(el, className)) {
                var existingNames = el.className;
                if (existingNames) {
                    el.className = existingNames + ' ';
                }
                el.className = el.className + className;
            }
        },

        /**
         * Remvoes a CSS class from an element.
         * @param {HTMLElement} el - The element to remove class from.
         * @param {string} className - The css class value to remove
         */
        removeClass: function (el, className) {
            var re;
            if (this.hasClass(el, className)) {

                if (el.className === className) {
                    // if the only class that exists,  remove to 
                     el.className = '';
                } else {
                    re = '[\\s]*' + className;
                    re = new RegExp(re, 'i');
                    el.className = el.className.replace(re, '');
                }
            }
        },

        /**
         * Checks if an element has a class.
         * @param {HTMLElement} el - The element to check.
         * @param {string} className - The css class value to check
         */
        hasClass: function (el, className) {
            var classes = el.className.split(' ');
            return classes.indexOf(className) !== -1;
        },

        /**
         * Creates an HTML Element from an html string.
         * @param {string} html - String of html
         * @returns {HTMLElement} - Returns and html element node
         */
        createHtmlElement: function (html) {
            var tempParentEl,
                el;
            if (html) {
                html = this.trim(html);
                tempParentEl = document.createElement('div');
                tempParentEl.innerHTML = html;
                el = tempParentEl.childNodes[0];
                return tempParentEl.removeChild(el);
            }
        },

        /**
         * Wrap a container element around another element.
         * @param {HTMLElement} el - The element to be wrapped
         * @param {string} html - The wrapper element
         */
        wrapHtmlElement: function (el, html) {
            var origContainer = el.parentNode,
                container = this.createHtmlElement(html);
            origContainer.replaceChild(container, el);
            container.appendChild(el);
            return container;
        },

        /**
         * Zaps whitespace from both ends of a string.
         * @param {string} val - The string value to trim
         * @returns {string} Returns a trimmed string
         */
        trim: function (val) {
            if (!String.prototype.trim) {
                String.prototype.trim = function () {
                    return val.replace(/^\s+|\s+$/g, '');
                };
            } else {
                val = val.trim();
            }
            return val;
        },

        /**
         * Gets a simplified mapping of all attributes of an element.
         * @param {HTMLElement} el - The element containing attributes
         * @returns {object} - Returns an object containing all attribute mappings
         */
        getElementAttrMap: function (el) {
            var attrs = el.attributes,
                map = {};
            if (attrs.length) {
                for (var i = 0; i &lt; attrs.length; i++) {
                    map[attrs[i].name] = attrs[i].value;
                }
            }
            return map;
        },

        /**
         * Gets a deeply nested property of an object.
         * @param {object} obj - The object to evaluate
         * @param {string} map - A string denoting where the property that should be extracted exists
         * @param {object} fallback - The fallback if the property does not exist
         */
        getNested: function (obj, map, fallback) {
            var mapFragments = map.split('.'),
                val = obj;
            for (var i = 0; i &lt; mapFragments.length; i++) {
                if (val[mapFragments[i]]) {
                    val = val[mapFragments[i]];
                } else {
                    val = fallback;
                }
            }
            return val;
        },

        /**
         * Gets element by its class name.
         * @param {string} className - The class name
         * @param {HTMLElement} [rootEl] - The root el used for scoping (optional)
         * @returns {NodeList|HTMLCollection} - Returns a node list if &lt; IE9 and HTML Collection otherwise.
         * TODO: does NOT support CSS2 selectors in IE8, update asap
         */
        getElementsByClassName: function (className, rootEl) {
            var el = rootEl || document;
            return el.getElementsByClassName(className);
        },

        /**
         * Gets the closest ancestor element that has a class.
         * @param {string} className - The class name that the ancestor must have to match
         * @param {HTMLElement} el - The source element
         */
        getClosestAncestorElementByClassName: function (className, el) {
            var result,
                parentNode = el.parentNode;
            // we must check if the node has classname property because some don't (#document element)
            while (parentNode && typeof parentNode.className === 'string') {
                if (this.hasClass(parentNode, className)) {
                    result = parentNode;
                    break;
                } else {
                    parentNode = parentNode.parentNode;
                }
            }
            return result;
        },

        /**
         * Adds an event listener to an element.
         * @param {HTMLElement} el - The element to listen to
         * @param {string} event - The event to listen to
         * @param {string|Function} listener - The name of the function (or the function itself) that should fire when the event happens
         * @param {Object} [context] - The context in which the function should be called
         * @param {Object} [options] - Object containing additional options
         * @param {Object} [options.useCapture] - Whether to use capture (see Web.API.EventTarget.addEventListener)
         */
        addEventListener: function (el, event, listener, context, options) {
            var _listener = listener;
            options = options || {};

            if (typeof _listener !== 'function') {
                _listener = this._createEventListener(context[listener], context);
            }

            el.addEventListener(event, _listener, options.useCapture);

            // cache event listener to remove later
            this._eventListenerMap = this._eventListenerMap || [];
            this._eventListenerMap.push({
                el: el,
                event: event,
                listener: _listener,
                listenerId: listener,
                context: context
            });
        },

        /**
         * Creates an event listener bounded to a context (useful for adding and removing events).
         * @param {Function} listener - The listener function
         * @param {Object} context - The context that should be used when the function is called
         * @returns {Function} Returns an event listener function bounded to the context
         * @private
         */
        _createEventListener: function (listener, context) {
            return function (e) {
                context = context || this;
                listener.apply(context, arguments);
            }
        },

        /**
         * Removes an event listener from an element.
         * @param {HTMLElement} el - The element that contains the event listener
         * @param {string} event - The event to remove
         * @param {string|Function} listener - The event listener function or (name of it) to be removed
         * @param {Object} [context] - The context of the listener that is being removed
         */
        removeEventListener: function (el, event, listener, context) {
            var map = this._eventListenerMap || [],
                i,
                obj;

            if (map.length) {
                for (i = 0; i &lt; map.length; i++) {
                    obj = map[i];
                    if (obj && obj.el === el && obj.event === event && obj.listenerId === listener && obj.context === context) {
                        el.removeEventListener(event, obj.listener);
                        this._eventListenerMap[i] = null;
                        break;
                    }
                }
            }
        },

        /**
         * Merges the contents of two or more objects.
         * @param {object} obj - The target object
         * @param {...object} - Additional objects who's properties will be merged in
         */
        extend: function (target) {
            var merged = target,
                source, i;
            for (i = 1; i &lt; arguments.length; i++) {
                source = arguments[i];
                for (var prop in source) {
                    if (source.hasOwnProperty(prop)) {
                        merged[prop] = source[prop];
                    }
                }
            }
            return merged;
        },

        /**
         * Converts a css timing unit value into milliseconds.
         * @param {string} val - The value string
         * @returns {Number} Returns the number of milliseconds
         */
        convertCssTimeValueToMilliseconds: function (val) {
            var number = this.convertCssUnitToNumber(val),
                unit = val.replace(number, '');
            if (unit === 's') {
                val = number * 1000;
            } else {
                val = number;
            }
            return val;
        },

        /**
         * Removes the unit (px, ms, etc) from a css value and converts it to a number.
         * @param {string} val - The css value
         * @returns {Number} Returns the number with the css value unit removed
         */
        convertCssUnitToNumber: function (val) {
            return Number(val.replace(/[a-z]+/, ''));
        },

        /**
         * Gets the computed property of an element.
         * @param {HTMLElement} el - The element from which to obtain the property value
         * @param {string} prop - The name of the property to get
         * @returns {string} Returns the value of the property
         */
        getCssComputedProperty: function (el, prop) {
            var style = window.getComputedStyle(el);
            return style.getPropertyValue(prop) || el.style[this.getJsPropName(prop)];
        },

        /**
         * Gets the computed property of an element.
         * @param {HTMLElement} el - The element from which to obtain the property value
         * @param {string} prop - The name of the property to get
         * @returns {string} Returns the value of the property
         * @deprecated since 1.1.0
         */
        getCssProperty: function (el, prop) {
            return this.getCssComputedProperty(el, prop);
        },

        /**
         * Takes a css property name and returns the javascript version of it.
         * @param {string} prop - The css property
         * @returns {string} Returns the javascript version
         */
        getJsPropName: function (prop) {
            // convert to camelCase
            prop = prop.replace(/-([a-z])/g, function (letter) {
                return letter[1].toUpperCase();
            });
            return prop;
        },

        /**
         * Gets the current IE version.
         * @returns {Number} Returns the IE version number
         */
        getIEVersion: function () {
            if (navigator.appName == 'Microsoft Internet Explorer') {
                //Create a user agent var
                var ua = navigator.userAgent;
                //Write a new regEx to find the version number
                var re = new RegExp('MSIE ([0-9]{1,}[.0-9]{0,})');
                //If the regEx through the userAgent is not null
                if (re.exec(ua) != null) {
                    //Set the IE version
                    return parseInt(RegExp.$1);
                }
            } else {
                return false;
            }
        },

        /**
         * Sets up the fallback polyfill for binding 'this' to functions.
         * @private
         */
        _setupBindPolyfill: function () {
            if (!Function.prototype.bind) {
                Function.prototype.bind = function (oThis) {
                    if (typeof this !== 'function') {
                        // closest thing possible to the ECMAScript 5
                        // internal IsCallable function
                        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
                    }

                    var aArgs = Array.prototype.slice.call(arguments, 1),
                        fToBind = this,
                        fNOP = function () {},
                        fBound = function () {
                            return fToBind.apply(this instanceof fNOP && oThis
                                ? this
                                : oThis,
                                aArgs.concat(Array.prototype.slice.call(arguments)));
                        };

                    fNOP.prototype = this.prototype;
                    fBound.prototype = new fNOP();

                    return fBound;
                };
            }
        }
    };

    return new Utils();
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="BaseFormElement.html">BaseFormElement</a></li><li><a href="ButtonToggle.html">ButtonToggle</a></li><li><a href="Checkbox.html">Checkbox</a></li><li><a href="Form.html">Form</a></li><li><a href="InputField.html">InputField</a></li></ul><h3>Namespaces</h3><ul><li><a href="Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Sun Nov 02 2014 15:55:22 GMT-0500 (EST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
